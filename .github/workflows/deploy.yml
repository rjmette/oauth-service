name: Deploy OAuth Service

on:
  push:
    branches: [master]
    paths:
      - 'src/**'
      - 'scripts/**'
      - 'package*.json'
      - '.github/workflows/**'
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  API_NAME: rbios-oauth-api

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      run: npm test

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/heads/')

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Package OAuth Lambda functions
      run: |
        echo "ğŸ“¦ Packaging OAuth lambda..."
        rm -rf /tmp/oauth-lambda
        mkdir -p /tmp/oauth-lambda

        # Copy all source files
        cp -r src/* /tmp/oauth-lambda/

        # Create package.json for Lambda
        cat > /tmp/oauth-lambda/package.json << 'EOF'
        {
          "name": "rbios-oauth-service",
          "version": "1.0.0",
          "type": "module",
          "dependencies": {
            "node-fetch": "^3.3.2"
          }
        }
        EOF

        cd /tmp/oauth-lambda
        zip -r /tmp/oauth-lambda.zip . -q
        cd -
        mv /tmp/oauth-lambda.zip oauth-lambda.zip

    - name: Deploy OAuth Lambda and API routes
      run: |
        set -e

        # Debug: Check AWS CLI availability and version
        echo "ğŸ” Checking AWS CLI setup..."
        which aws || echo "AWS CLI not found in PATH"
        aws --version || echo "AWS CLI version check failed"
        aws sts get-caller-identity || echo "AWS credentials check failed"

        REGION="${{ env.AWS_REGION }}"
        API_NAME="${{ env.API_NAME }}"
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

        LOGIN_FN="rbios-oauth-login"
        CB_FN="rbios-oauth-callback"

        # Determine branch and stage
        BRANCH="${GITHUB_REF#refs/heads/}"
        if [ "$BRANCH" = "master" ]; then
          STAGE="prod"
          USE_CUSTOM_DOMAIN=1
        else
          # Sanitize branch for stage name
          SANITIZED=$(echo "$BRANCH" | tr -c '[:alnum:]-' '-' | sed -E 's/^-+|-+$//g' | cut -c1-40)
          STAGE="branch-$SANITIZED"
          USE_CUSTOM_DOMAIN=0
        fi

        echo "Using stage: $STAGE (branch: $BRANCH)"

        # Helper: wait for Lambda to be Active/Successful
        wait_for_function_ready() {
          local FN_NAME=$1
          local max_attempts=20
          local attempt=1
          local base_delay=2
          while [ $attempt -le $max_attempts ]; do
            local state=$(aws lambda get-function --function-name "$FN_NAME" --query 'Configuration.State' --output text 2>/dev/null || echo "NotFound")
            local last=$(aws lambda get-function --function-name "$FN_NAME" --query 'Configuration.LastUpdateStatus' --output text 2>/dev/null || echo "Unknown")
            if [ "$state" = "Active" ] && [ "$last" != "Failed" ]; then
              echo "  â€¢ $FN_NAME ready (state=$state, last=$last, attempt $attempt/$max_attempts)";
              return 0
            fi
            if [ "$state" = "Failed" ] || [ "$last" = "Failed" ]; then
              echo "  âœ— $FN_NAME in failed state (state=$state, last=$last)";
              return 1
            fi
            local delay=$((base_delay * (2 ** (attempt - 1))))
            if [ $delay -gt 30 ]; then delay=30; fi
            echo "  â€¦ waiting for $FN_NAME (state=$state, last=$last), sleeping ${delay}s"
            sleep $delay
            attempt=$((attempt + 1))
          done
          echo "  âœ— Timeout waiting for $FN_NAME to be ready"
          return 1
        }

        # Create or get API Gateway
        echo "ğŸ”§ Setting up API Gateway..."
        API_ID=$(aws apigatewayv2 get-apis --query "Items[?Name=='$API_NAME'].ApiId" --output text)
        if [ -z "$API_ID" ] || [ "$API_ID" = "None" ]; then
          API_ID=$(aws apigatewayv2 create-api \
            --name $API_NAME \
            --protocol-type HTTP \
            --cors-configuration AllowOrigins="https://create.rbios.net,https://prompts.rbios.net,http://localhost:5173,http://localhost:5174",AllowMethods="GET,OPTIONS",AllowHeaders="Content-Type,Authorization",AllowCredentials=true \
            --query 'ApiId' --output text)
        fi

        API_URL="https://$API_ID.execute-api.$REGION.amazonaws.com/$STAGE"

        # Use custom domain for production, direct API URL for branches
        if [ "$USE_CUSTOM_DOMAIN" = "1" ]; then
          OAUTH_API_URL="https://api.rbios.net"
        else
          OAUTH_API_URL="$API_URL"
        fi

        # Create or update functions
        upsert_fn() {
          local FN_NAME=$1
          local HANDLER=$2

          if aws lambda get-function --function-name "$FN_NAME" > /dev/null 2>&1; then
            aws lambda update-function-code --function-name "$FN_NAME" --zip-file fileb://oauth-lambda.zip > /dev/null
          else
            aws lambda create-function \
              --function-name "$FN_NAME" \
              --runtime nodejs20.x \
              --role arn:aws:iam::$ACCOUNT_ID:role/lambda-execution-role \
              --handler $HANDLER \
              --zip-file fileb://oauth-lambda.zip \
              --timeout 30 \
              --memory-size 256 > /dev/null
          fi

          # Wait for function to be Active before updating configuration
          wait_for_function_ready "$FN_NAME"

          aws lambda update-function-configuration \
            --function-name "$FN_NAME" \
            --environment "Variables={GITHUB_CLIENT_ID=${{ secrets.GITHUB_CLIENT_ID }},GITHUB_CLIENT_SECRET=${{ secrets.GITHUB_CLIENT_SECRET }},NODE_ENV=production,OAUTH_API_URL=$OAUTH_API_URL}" > /dev/null

          # Wait again after configuration update
          wait_for_function_ready "$FN_NAME"

          # Allow API Gateway invoke
          aws lambda add-permission \
            --function-name "$FN_NAME" \
            --statement-id "allow-apigw-${FN_NAME}" \
            --action lambda:InvokeFunction \
            --principal apigateway.amazonaws.com \
            --source-arn "arn:aws:execute-api:$REGION:$ACCOUNT_ID:$API_ID/*" > /dev/null 2>&1 || true
        }

        # Create stage (idempotent)
        aws apigatewayv2 create-stage --api-id "$API_ID" --stage-name "$STAGE" --auto-deploy > /dev/null 2>&1 || true

        upsert_fn "$LOGIN_FN" "handlers/oauth-login.handler"
        upsert_fn "$CB_FN" "handlers/oauth-callback.handler"

        # Create or update integrations and routes (idempotent)
        upsert_integ_route() {
          local METHOD=$1
          local PATH=$2
          local FN_NAME=$3
          local ROUTE_KEY="$METHOD $PATH"
          local INTEGRATION_URI="arn:aws:lambda:$REGION:$ACCOUNT_ID:function:$FN_NAME"

          # Check if route already exists
          EXISTING_ROUTE_ID=$(aws apigatewayv2 get-routes --api-id "$API_ID" --query "Items[?RouteKey=='$ROUTE_KEY'].RouteId" --output text 2>/dev/null || echo "")

          if [ -n "$EXISTING_ROUTE_ID" ] && [ "$EXISTING_ROUTE_ID" != "None" ]; then
            echo "  Route $ROUTE_KEY already exists ($EXISTING_ROUTE_ID), checking integration..."

            # Get existing integration ID from route
            EXISTING_TARGET=$(aws apigatewayv2 get-route --api-id "$API_ID" --route-id "$EXISTING_ROUTE_ID" --query "Target" --output text 2>/dev/null || echo "")
            EXISTING_INTEGRATION_ID="${EXISTING_TARGET#integrations/}"

            if [ -n "$EXISTING_INTEGRATION_ID" ] && [ "$EXISTING_INTEGRATION_ID" != "None" ]; then
              # Check if integration URI is correct
              CURRENT_URI=$(aws apigatewayv2 get-integration --api-id "$API_ID" --integration-id "$EXISTING_INTEGRATION_ID" --query "IntegrationUri" --output text 2>/dev/null || echo "")

              if [ "$CURRENT_URI" = "$INTEGRATION_URI" ]; then
                echo "  Integration already correct, skipping"
                return 0
              else
                echo "  Integration URI incorrect ($CURRENT_URI vs $INTEGRATION_URI), updating..."
                aws apigatewayv2 update-integration --api-id "$API_ID" --integration-id "$EXISTING_INTEGRATION_ID" --integration-uri "$INTEGRATION_URI" > /dev/null 2>&1 || true
                return 0
              fi
            fi
          fi

          # Create new integration
          echo "  Creating new integration for $ROUTE_KEY..."
          INTEGRATION_ID=$(aws apigatewayv2 create-integration \
            --api-id "$API_ID" \
            --integration-type AWS_PROXY \
            --integration-uri "$INTEGRATION_URI" \
            --payload-format-version 2.0 \
            --query 'IntegrationId' --output text)

          # Delete existing route if exists (to replace with new integration)
          if [ -n "$EXISTING_ROUTE_ID" ] && [ "$EXISTING_ROUTE_ID" != "None" ]; then
            aws apigatewayv2 delete-route --api-id "$API_ID" --route-id "$EXISTING_ROUTE_ID" > /dev/null 2>&1 || true
          fi

          # Create new route
          aws apigatewayv2 create-route --api-id "$API_ID" --route-key "$ROUTE_KEY" --target "integrations/$INTEGRATION_ID" > /dev/null
          echo "  Created route $ROUTE_KEY with integration $INTEGRATION_ID"
        }

        upsert_integ_route GET /oauth/login "$LOGIN_FN"
        upsert_integ_route GET /oauth/callback "$CB_FN"

        if [ "$USE_CUSTOM_DOMAIN" = "1" ]; then
          # Custom domain mapping for master only
          CUSTOM_DOMAIN="api.rbios.net"
          echo "Looking for SSL certificate for $CUSTOM_DOMAIN..."

          # Check if AWS CLI is available and properly configured
          if ! command -v aws &> /dev/null; then
            echo "âš ï¸  AWS CLI not found, skipping custom domain setup"
            echo "âœ… OAuth endpoints (master) deployed at $API_URL"
          else
            CERT_ARN=$(aws acm list-certificates --region us-east-1 --query "CertificateSummaryList[?DomainName=='*.rbios.net' || DomainName=='rbios.net'].CertificateArn" --output text 2>/dev/null | head -n1 || echo "")

            if [ -n "$CERT_ARN" ] && [ "$CERT_ARN" != "None" ] && [ "$CERT_ARN" != "" ]; then
              echo "Found certificate: $CERT_ARN"
              aws apigatewayv2 create-domain-name --domain-name "$CUSTOM_DOMAIN" --domain-name-configurations CertificateArn="$CERT_ARN" > /dev/null 2>&1 || true
              sleep 5
              aws apigatewayv2 create-api-mapping --domain-name "$CUSTOM_DOMAIN" --api-id "$API_ID" --stage "$STAGE" --api-mapping-key "oauth" > /dev/null 2>&1 || true
              echo "âœ… OAuth endpoints (master) deployed at https://$CUSTOM_DOMAIN/oauth"
            else
              echo "âš ï¸  No SSL certificate found for $CUSTOM_DOMAIN, using API Gateway URL"
              echo "âœ… OAuth endpoints (master) deployed at $API_URL"
            fi
          fi
        else
          echo "âœ… OAuth endpoints (branch) deployed at $API_URL"
        fi

    - name: Cleanup
      run: rm -f oauth-lambda.zip

  notify:
    needs: [test, deploy]
    runs-on: ubuntu-latest
    if: always() && github.ref == 'refs/heads/master' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')

    steps:
    - name: Deployment Summary
      run: |
        echo "ğŸš€ OAuth Service Deployment Summary"
        echo "================================="
        echo "ğŸŒ Target URL: https://api.rbios.net/oauth"
        echo "ğŸŒ Region: ${{ env.AWS_REGION }}"
        echo "ğŸ“Š Status: ${{ needs.deploy.result }}"

        if [ "${{ needs.deploy.result }}" = "success" ]; then
          echo "âœ… OAuth service deployment completed successfully!"
          echo "ğŸ‰ Service is now live!"
          echo ""
          echo "Available endpoints:"
          echo "- Login: https://api.rbios.net/oauth/login?project=create"
          echo "- Login: https://api.rbios.net/oauth/login?project=prompts"
          echo "- Callback: https://api.rbios.net/oauth/callback"
        else
          echo "âŒ Deployment failed"
          echo "ğŸ” Check the deployment logs for details"
        fi